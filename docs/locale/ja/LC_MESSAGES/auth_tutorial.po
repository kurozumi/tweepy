# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2009, Joshua Roesslein
# This file is distributed under the same license as the tweepy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tweepy 3.6.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-11-24 23:01+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../auth_tutorial.rst:6
msgid "Authentication Tutorial"
msgstr ""

#: ../../auth_tutorial.rst:9
msgid "Introduction"
msgstr ""

#: ../../auth_tutorial.rst:11
msgid ""
"Tweepy supports oauth authentication. Authentication is handled by the "
"tweepy.AuthHandler class."
msgstr ""

#: ../../auth_tutorial.rst:15
msgid "OAuth Authentication"
msgstr ""

#: ../../auth_tutorial.rst:17
msgid ""
"Tweepy tries to make OAuth as painless as possible for you. To begin the "
"process we need to register our client application with Twitter. Create a"
" new application and once you are done you should have your consumer "
"token and secret. Keep these two handy, you'll need them."
msgstr ""

#: ../../auth_tutorial.rst:23
msgid ""
"The next step is creating an OAuthHandler instance. Into this we pass our"
" consumer token and secret which was given to us in the previous "
"paragraph::"
msgstr ""

#: ../../auth_tutorial.rst:29
msgid ""
"If you have a web application and are using a callback URL that needs to "
"be supplied dynamically you would pass it in like so::"
msgstr ""

#: ../../auth_tutorial.rst:35
msgid ""
"If the callback URL will not be changing, it is best to just configure it"
" statically on twitter.com when setting up your application's profile."
msgstr ""

#: ../../auth_tutorial.rst:39
msgid ""
"Unlike basic auth, we must do the OAuth \"dance\" before we can start "
"using the API. We must complete the following steps:"
msgstr ""

#: ../../auth_tutorial.rst:42
msgid "Get a request token from twitter"
msgstr ""

#: ../../auth_tutorial.rst:44
msgid "Redirect user to twitter.com to authorize our application"
msgstr ""

#: ../../auth_tutorial.rst:46
msgid ""
"If using a callback, twitter will redirect the user to us. Otherwise the "
"user must manually supply us with the verifier code."
msgstr ""

#: ../../auth_tutorial.rst:50
msgid "Exchange the authorized request token for an access token."
msgstr ""

#: ../../auth_tutorial.rst:52
msgid "So let's fetch our request token to begin the dance::"
msgstr ""

#: ../../auth_tutorial.rst:59
msgid ""
"This call requests the token from twitter and returns to us the "
"authorization URL where the user must be redirect to authorize us. Now if"
" this is a desktop application we can just hang onto our OAuthHandler "
"instance until the user returns back. In a web application we will be "
"using a callback request. So we must store the request token in the "
"session since we will need it inside the callback URL request. Here is a "
"pseudo example of storing the request token in a session::"
msgstr ""

#: ../../auth_tutorial.rst:70
msgid ""
"So now we can redirect the user to the URL returned to us earlier from "
"the get_authorization_url() method."
msgstr ""

#: ../../auth_tutorial.rst:73
msgid ""
"If this is a desktop application (or any application not using callbacks)"
" we must query the user for the \"verifier code\" that twitter will "
"supply them after they authorize us. Inside a web application this "
"verifier value will be supplied in the callback request from twitter as a"
" GET query parameter in the URL."
msgstr ""

#: ../../auth_tutorial.rst:87
msgid ""
"The final step is exchanging the request token for an access token. The "
"access token is the \"key\" for opening the Twitter API treasure box. To "
"fetch this token we do the following::"
msgstr ""

#: ../../auth_tutorial.rst:104
msgid ""
"It is a good idea to save the access token for later use. You do not need"
" to re-fetch it each time. Twitter currently does not expire the tokens, "
"so the only time it would ever go invalid is if the user revokes our "
"application access. To store the access token depends on your "
"application. Basically you need to store 2 string values: key and "
"secret::"
msgstr ""

#: ../../auth_tutorial.rst:114
msgid ""
"You can throw these into a database, file, or where ever you store your "
"data. To re-build an OAuthHandler from this stored access token you would"
" do this::"
msgstr ""

#: ../../auth_tutorial.rst:121
msgid ""
"So now that we have our OAuthHandler equipped with an access token, we "
"are ready for business::"
msgstr ""

